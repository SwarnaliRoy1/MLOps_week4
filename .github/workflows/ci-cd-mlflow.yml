name: CI + CD (DVC data, MLflow model → GAR + GKE)

on:
  push:
    branches: [ main, week6 ]
  pull_request:
    branches: [ main, week6 ]

permissions:
  contents: write
  pull-requests: write
  id-token: write

env:
  # ---- Shared CI/CD env ----
  MODEL_NAME: Iris-Classifier
  DATA_CSV_PATH: data/data.csv
  TARGET_COL: species
  GAR_REGION: us-central1
  GAR_REPO: my-repo
  IMAGE_NAME: iris-api
  CLUSTER_NAME: gke-iris-cluster
  CLUSTER_LOCATION: us-central1
  NAMESPACE: default

jobs:
  ci:
    name: CI — DVC + MLflow sanity
    runs-on: ubuntu-latest
    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}

    steps:
      - name: Debug event/ref
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "ref=${{ github.ref }}"
          echo "ref_name=${{ github.ref_name }}"
          echo "actor=${{ github.actor }}"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Set up CML
        uses: iterative/setup-cml@v2

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ hashFiles('**/req.txt') }}
          restore-keys: pip-${{ runner.os }}-

      - name: Install system deps
        run: |
          sudo apt-get update -y
          sudo apt-get install -y git-lfs
          git lfs install

      - name: Auth to GCP (for DVC on GCS)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r req.txt

      - name: DVC pull data from GCS
        run: dvc pull -v

      - name: Resolve MLflow model URI (latest version)
        id: resolve
        env:
          MLFLOW_TRACKING_URI: ${{ env.MLFLOW_TRACKING_URI }}
          MODEL_NAME: ${{ env.MODEL_NAME }}
        run: |
          python - <<'PY'
          import os, sys, mlflow
          from mlflow.tracking import MlflowClient

          mlflow.set_tracking_uri(os.environ["MLFLOW_TRACKING_URI"])
          name = os.environ["MODEL_NAME"]
          client = MlflowClient()

          try:
              client.get_registered_model(name)
          except Exception:
              print(f"::error::Registered model '{name}' not found at {os.environ['MLFLOW_TRACKING_URI']}.")
              sys.exit(1)

          versions = client.search_model_versions(f"name='{name}'")
          if not versions:
              print(f"::error::Model '{name}' has no versions.")
              sys.exit(1)

          latest = max(versions, key=lambda v: int(v.version))
          uri = f"models:/{name}/{latest.version}"
          print(f"Resolved MODEL_URI: {uri}")
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"model_uri={uri}\n")
          PY

      - name: Evaluate model on CSV
        env:
          MODEL_URI: ${{ steps.resolve.outputs.model_uri }}
          DATA_CSV_PATH: ${{ env.DATA_CSV_PATH }}
          TARGET_COL: ${{ env.TARGET_COL }}
        run: |
          python - <<'PY'
          import os, json, pandas as pd, mlflow
          data_csv = os.environ["DATA_CSV_PATH"]
          target = os.environ["TARGET_COL"]
          model_uri = os.environ["MODEL_URI"]

          df = pd.read_csv(data_csv)
          X = df.drop(columns=[target])
          y = df[target]

          model = mlflow.pyfunc.load_model(model_uri)
          y_pred = model.predict(X)
          acc = float((y_pred == y).mean())

          report = {"model_uri": model_uri, "rows": int(len(df)), "accuracy": acc}
          print(json.dumps(report, indent=2))
          with open("sanity.json", "w") as f:
            json.dump(report, f, indent=2)
          PY

      - name: CML comment (sanity report)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          REPO_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo '### Sanity Check (DVC data + MLflow model)' > report.md
          echo '' >> report.md
          echo '**Model URI:** `${{ steps.resolve.outputs.model_uri }}`' >> report.md
          echo '' >> report.md
          echo '\`\`\`json' >> report.md
          cat sanity.json >> report.md
          echo '\`\`\`' >> report.md
          cml comment create --publish report.md

  cd:
    name: CD — Build → GAR → GKE
    needs: ci
    if: github.event_name == 'push' && (github.ref_name == 'main' || github.ref_name == 'week6')
    runs-on: ubuntu-latest
    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

    steps:
      - name: Debug event/ref
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "ref=${{ github.ref }}"
          echo "ref_name=${{ github.ref_name }}"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Auth to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GAR_REGION }}-docker.pkg.dev -q

      - name: Build & push Docker image to GAR (fastapi/)
        env:
          IMG_SHA: ${{ github.sha }}
          IMAGE_URI: ${{ env.GAR_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPO }}/${{ env.IMAGE_NAME }}
        run: |
          echo "Listing repo root"; ls -la
          echo "Listing fastapi dir"; ls -la fastapi

          DOCKER_BUILDKIT=0 docker build \
            -f fastapi/Dockerfile \
            -t ${IMAGE_URI}:${IMG_SHA} \
            -t ${IMAGE_URI}:latest \
            fastapi

          docker push ${IMAGE_URI}:${IMG_SHA}
          docker push ${IMAGE_URI}:latest

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.CLUSTER_NAME }}
          location: ${{ env.CLUSTER_LOCATION }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Generate & apply manifests (no repo files)
        env:
          IMG_SHA: ${{ github.sha }}
          IMAGE_URI: ${{ env.GAR_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPO }}/${{ env.IMAGE_NAME }}
          NAMESPACE: ${{ env.NAMESPACE }}
        run: |
          set -euo pipefail
          DEPLOY=$(mktemp)
          SERVICE=$(mktemp)

          cat > "$DEPLOY" <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: iris-api
            labels: { app: iris-api }
          spec:
            replicas: 2
            revisionHistoryLimit: 3
            strategy:
              type: RollingUpdate
              rollingUpdate: { maxUnavailable: 0, maxSurge: 1 }
            selector:
              matchLabels: { app: iris-api }
            template:
              metadata:
                labels: { app: iris-api }
              spec:
                containers:
                  - name: iris-api
                    image: ${IMAGE_URI}:${IMG_SHA}
                    imagePullPolicy: IfNotPresent
                    ports:
                      - containerPort: 8000
                    readinessProbe:
                      httpGet: { path: "/", port: 8000 }
                      initialDelaySeconds: 5
                      periodSeconds: 10
                      timeoutSeconds: 2
                      failureThreshold: 6
                    livenessProbe:
                      httpGet: { path: "/", port: 8000 }
                      initialDelaySeconds: 15
                      periodSeconds: 20
                      timeoutSeconds: 2
                      failureThreshold: 3
                    resources:
                      requests: { cpu: "100m", memory: "256Mi" }
                      limits:   { cpu: "500m", memory: "512Mi" }
          EOF

          cat > "$SERVICE" <<EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: iris-api
            labels: { app: iris-api }
          spec:
            type: ClusterIP
            selector: { app: iris-api }
            ports:
              - name: http
                port: 80
                targetPort: 8000
          EOF

          kubectl get ns "${NAMESPACE}" >/dev/null 2>&1 || kubectl create ns "${NAMESPACE}"
          kubectl apply -n "${NAMESPACE}" -f "$DEPLOY"
          kubectl apply -n "${NAMESPACE}" -f "$SERVICE"

      - name: Rollout status
        run: |
          kubectl rollout status deployment/iris-api -n ${{ env.NAMESPACE }} --timeout=180s

      - name: In-cluster smoke test (GET /)
        run: |
          kubectl run smoke --rm -i --restart=Never -n ${{ env.NAMESPACE }} \
            --image=curlimages/curl -- \
            -sS http://iris-api.${{ env.NAMESPACE }}.svc.cluster.local/ \
            | tee smoke_root.txt
          grep -q 'Welcome to the Iris Classifier API' smoke_root.txt
